# Chapter 3 :: Pipelining

## 3.1 Trasmit data to vertex shader

* ***Vertex Shader*** 는 *OpenGL* 파이프라인의 첫번째로 프로그래밍이 가능한 스테이지다. 정점 쉐이더는 각 정점에 대해서 처리를 하는데, 처리를 할 때 필요한 데이터는 이전 스테이지인 ***Vertex Fetch*** 고정 함수 스테이지에서 VAO 의 속성을 자동으로 가져와 입력으로 넣어준다.

### 3.1.1 Vertex Attribute

* GLSL에서 쉐이더로 데이터를 가져오거나 다른 스테이지로 내보낼 때, **`in`** **`out`** specifier 을 사용해서 지시어로 전역 변수를 선언할 수 있다. 
  * *OpenGL* 파이프라인 시작 시, `in` 키워드를 사용해서 각 쉐이더에 입력을 제공할 수 있다. 정점 쉐이더의 경우에는 입력이 정점 페칭에 의해 자동으로 이루어진다. 
    이 **변수**를 **Vertex attribute** 라고 한다. 
  * 정점 속성은 Vertex data 가 OpenGL 파이프라인에 어떻게 소개될 지를 결정한다.

버텍스 속성을 선언하려면 `in` 지시어로 버텍스 쉐이더에 변수를 선언하면 된다.

``` c++
const GLchar* vs[] = {
    "#version 430 core \n"
    "layout (location = 0) in vec4 offset; \n"
    "void main() { \n"
    "/*! *** /"
};
```

이렇게 해서 버텍스 쉐이더는 *Vertex attribute* 로 *offset* 이라는 변수를 가진다. 정점 쉐이더의 입력 값은 Vertex fetch 스테이지에서 자동으로 값이 채워질 것이다. (VAO) 

* ***`glVertexAttrib##()`*** 을 사용해서 해당 버텍스 쉐이더의 변수의 내용을 채울 수 있다. 중요한 점은, 속성의 값이 채워질 때 해당 값은 **VAO** 에 바인딩이 되지 않으면 안되므로, 사전에 `glBindVertexArray` 로 쉐이더에 넘길 VAO 를 활성화 시켜야 한다.
  * 위에서는 `vec4` 타입을 가지고 있기 때문에 
    *`glVertexAttrib4fv(GLuint index, const GLfloat_ptr v)`* 을 사용한다. 
    여기서 **index** 인자는 속성을 참조하기 위한 **위치 값** 이다. 
  * offset 속성을 선언할 때, **`layout(location = 0)`** 이라는 코드가 있는데, 이 코드는 ***Layout specifier*** 을 사용해서 버텍스 속성의 위치를 $ 0 $으로 설정한다. 
  * 값 자체는 **매 프레임마다 갱신할 필요가 없다.** 프레임이 갱신될 때 VAO 에 대입한 값이 자동으로 지워지지는 않는다.

## 3.2 Data transfer between the stage.

* 한 쉐이더 스테이지에서 다른 쉐이더 스테이지로 동일한 변수에 `in` 및 `out` 키워드를 사용해서 데이터를 전달할 수도 있다. 한 쉐이더에서 **출력 변수**에 저장하는 값은 다음 쉐이더 스테이지 (링크된) 에서 **`in`** 키워드로 선언된 **같은 이름의 변수**로 보내진다. 

### 3.2.1 Interface block

* `in` `out` specifier 등을 통해서 데이터를 주고 받을 때, ***Interface block*** 을 사용해서 여러 변수를 하나의 구조체로 묶어서 다음 쉐이더 스테이지에 넘길 수 있도록 할 수 있다. 인터페이스 블록을 선언하는 것은 구조체와 매우 유사하다.

``` c++
/*! Vertex shader */
out VS_OUT {
    vec4 color;
} vs_out;
/*! Fragment shader */
in VS_OUT {
    vec4 color;
} fs_in;
```

* *Interface block* 은 대문자의 블록 이름과 소문자의 인스턴스 이름을 가진다. **주의**해야 할 점은, 일반 변수와는 다르게 인터페이스 블록은 **블록 이름**을 가지고 매칭이 된다는 것이다. 
  * 그 이유는, 첫 번째로 블록을 참조하는 이름이 각 스테이지별로 다르게 함으로써 혼동을 줄이고자 함이다.
  * 두 번째로는 스테이지간에 걸쳐서 단일 아이템들이 배열로도 사용될 수 있기 때문이다.

## 3.3 Tessellation

* ***Tessellation*** 은 단순한 형태의 프리미비트를 (**Patch**) 더 작고 단순한 여러 개의 렌더링 가능한 프리미티브로 분할하는 작업을 말한다.
* *OpenGL* 은 테셀레이션을 수행하는 고정 함수 스테이지가 존재하며, 이 테셀레이션 엔진은 사각형, 삼각형, 등의 메쉬를 기본 프리미티브로 분할하는 역할을 가진다. 이 프리미티브들은 *rasterization* 에 의해 픽셀로 변환되어 처리될 수 있다.
  * 이론적으로 *Tessellation* 은 Vertex shader 다음에 위치하며 ***TCS, FFTE, TES*** 세 부분으로 나뉜다.

### 3.3.1 Tessellation Control Shader

테셀레이션 스테이지 중 첫번째 단계로, 버텍스 쉐이더로부터 입력을 받아서 주로 두 가지 일을 한다.

1. Tessellation engine 에 보낼 **테셀레이션의 레벨** 을 결정하는 역할
2. 고정 함수 테셀레이션 엔진이 수행된 다음에 **TES 에 보낼 데이터를 생성하는 일**.

* *OpenGL* 에서 많은 프리미티브로 분해될 고차 프리미티브인 ***Patch*** 는 여러 ***Control point*** 로 만들어진다. 패치 당 컨트롤 포인트(제어점) 개수는 변경이 가능하다.
  * ***`glPatchParameteri(GLenum name, GLint value)`*** 
    함수로 가능한데, 첫 번째 인자가 **GL_PATCH_VERTICES** 이며, value 인자를 패치당 생성할 제어점 개수로 하여 호출하면 된다.
    * 기본으로 제어점의 개수는 3개로 고정되어 있기 때문에, 굳이 건드리지 않아도 된다.
* 테셀레이션이 활성화 되면, **버텍스 쉐이더는 제어점당 한 번씩** 수행되며, *TCS* 는 **제어점들의 그룹** 단위로 수행된다. 이 때 각 그룹 단위의 크기는 패치 당 정점 개수와 동일하다. 왜냐면 정점이 제어점의 역할을 하기 때문이다.
  * 그래서 테셀레이션이 활성화 될 때, **버텍스 쉐이더의 결과는 그룹 단위로** *TCS* 의 입력으로 전달된다.
  * 패치당 컨트롤 포인트 개수는 다를 수 있기 때문에 **TCS 에서 입력받은 그룹 단위의 제어점 개수**는 **TES 등에 출력할 개수와 다를 수 있다.**
* *TCS* 가 생산하는 제어점 개수는 출력 레이아웃 지시어 (`out`) 을 사용해서 쓸 수 있다.
  * `layout (vertices = N) out;`
    여기서 $ N $ 은 패치 당 제어점 개수이다.
* 따라서 ***TCS*** 는 출력 제어점의 값을 계산하는 일, 고정 함수 테셀레이션 엔진으로 보내는 결과 패치에 대한 테셀레이션 레벨 인자를 설정하는 일을 담당한다.
  * 출력 테셀레이션 인자 레벨은 ***gl_TessLevelInner*** 와 ***gl_TessLevelOuter*** 내장 출력 변수로 설정을 할 수 있다. 다만 이 경우 두 변수는 현재 배치의 제어점의 개수가 몇 개인가에 따라서 설정할 수 있는 인자 수가 달라질 수 있다. 
  * 그 외의 파이프라인으로 내려가는 다른 데이터들은 **`out`** 으로 선언된 변수이거나 특별 내장된 **`gl_out`** 배열 변수로 저장이 된다.
* ***TCS*** 의 내장 변수인 **gl_InvocationID** 는 `in` 과 `out` 배열에 대한 *인덱스*로 사용된다. 이 변수는 패치 내 제어점에 대한 *zero-based* 인덱스이다.


``` c++
#version 430 core
layout (vertices = 3) out;
void main() {
    if (gl_InvocationID == 0) {
        gl_TessLevelInner[0] = 5.0;
        gl_TessLevelOuter[1] = 5.0; gl_TessLevelOuter[2] = 5.0; gl_TessLevelOuter[0] = 5.0;
    }
    gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
}
```

위 코드에서는 내부와 외부 테셀레이션 레벨을 5로 설정해서, 다음 스테이지의 고정 함수 테셀레이션 엔진에 요청을 하고 있다. 그리고 레이아웃 지시어를 사용해서 입력을 출력으로 복사한다.

### 3.3.2 Tessellation Engine

* 패치로 표현되는 고차 프리미티브를 작은 프리미티브로 분할하는 역할을 가진다. 테셀레이션 엔진이 **출력 프리미티브**를 생성하면, 만들어진 해당 버텍스들은 ***TES*** 로 전달된다. 그리고 *TES* 는 결과 프리미티브들을 변환해서 Geometry 후에 진행될 고정 함수 스테이지인 ***Rasterization*** 에서 래스터화가 가능한 형태로 만든다.

### 3.3.3 Tessellation Evaluation Shader

* 테셀레이션 엔진이 수행되면 프리미티브에 대한 많은 출력 버텍스가 생긴다. 이 버텍스 배치 단위들은 **테셀레이션 이벨류에이션 쉐이더** ***(TES)*** 로 전달된다. 주의해야 할 점은, 테셀레이션 레벨이 높으면 쉐이더가 많이 수행될 수 밖에 없기 때문에 복잡한 쉐이더와 높은 테셀레이션 레벨을 사용한다면 성능에 주의한다.

``` c++
"#version 430 core                                            \n"
"                                                             \n"
"layout (triangles, equal_spacing, cw) in;                    \n"
"                                                             \n"
"void main(void)                                              \n"
"{                                                            \n"
"    gl_Position = (gl_TessCoord.x * gl_in[0].gl_Position) +  \n"
"                  (gl_TessCoord.y * gl_in[1].gl_Position) +  \n"
"                  (gl_TessCoord.z * gl_in[2].gl_Position);   \n"
"}                                                            \n"
```

1. 쉐이더 시작 부분에 보면, **레이아웃 지시어**로 ***테셀레이션 모드를 설정***하는 것을 알 수 있다. 첫 번째 인자에서 볼 수 있듯이, ***triangles*** 로, 삼각형으로 프리미티브를 사용하는 모드를 선택한다.

   * 다른 지시어인 `equal_spacing` 과 `cw` 는 분할된 폴리곤 가장 자리를 따라서, *동일한 간격*으로 부수 정점이 **생성**되도록 하는 옵션, 그리고 *시계 방향*으로 **버텍스 감기**를 사용해서 최종 프리미티브 삼각형을 생성하도록 하는 옵션이다.

     > 자세한 사항은 Chapter 8.1 절 테셀레이션에서 설명한다.

2. 그리고 ***`gl_Position`*** 에 값을 할당한다. 두 개 이상의 내장 변수를 사용해서 값을 계산한다.

   * ***`gl_TessCoord`*** 는 테셀레이터 엔진이 생성한 **정점의 무게중심 좌표**이다.
   * 두 번째는 `gl_in[]` 구조체 배열의 `gl_Position` 멤버이기 때문에, **TCS** 에서 `gl_out[]` 과 동일하다. 위 코드에서는 기존 정점에 대해 아무것도 하지 않으며 원본 입력된 삼각형 패치와 정확히 동일하다. (다만 분할은 되어있다)

기존 렌더링 모드로는 테셀레이션이 된 것을 확인할 수 없기 때문에, 폴리곤의 렌더링 모드를 바꿔야 한다.
이는 ***`glPolygonMode(GLenum face, GLenum mode)`*** 로 적용이 가능하다.

* *face* 인자는 어떤 타입의 폴리곤에 적용할지를 물으며, `GL_FRONT` `GL_BACK` `GL_FRONT_AND_BACK` 으로 구성된다. 
  `mode` 인자는 폴리곤이 어떻게 그려질 것인지를 설정한다. `GL_LINE` `GL_FILL` 등이 있다.

## 3.4 Geometry shader

* ***Geometry shader*** 스테이지는 Vertex 와 Rasterization 스테이지의 사잇 단계에 있으며, *Rasterization* 이전의 **front-end** 스테이지로는 마지막 단계에 위치한 프로그래밍 가능한 쉐이더 스테이지이다. 
  * **TES** 에서 부수로 만들어진 정점의 프리미티브를 입력으로 받기 때문에 (설령 `in` 을 명시적으로 하지 않았다고 해도) **Geometry shader** 는 **프리미티브당 한 번씩** 수행되며, 현재 처리하고 있는 프리미티브를 구성하는 모든 버텍스에 대한 입력 정점 데이터에 접근할 수 있다.
* 지오메트리 쉐이더는 **프로그래밍을 통해서 데이터 정점의 양을 증가시키거나 줄일 수도 있는 유일한 쉐이더 스테이지**이다. 테셀레이션의 경우에는 레벨을 정해서 암묵적으로만 가능하나, 지오메트리는 코드로 명시적으로 증가량을 조절할 수 있다.
* 지오메트리 쉐이더에서 프리미티브를 구성하는 정점과 프리미티브 자체를 묶어서 *Primitive assembly* 및 *Rasterization* 으로 내보낼려면 다음과 같은 함수를 쓴다.
  * ***`EmitVertex()`***
    ***`EmitPrimitive()`***
    인자는 없으며, 대신에 `gl_Position` 내부 인자를 통해 해당 정점의 위치를 결정해야 한다.
* 지오메트리 쉐이더는 Pipeline 중간에서 **프리미티브의 모드를 변경**할 수 있다. 예를 들면, 원래 삼각형이었을 프리미티브 입력을 선이나 점으로 출력하게 할 수 있다. 이는 위 함수를 통해서 가능하다. 또는 점으로부터 삼각형을 만드는 것도 가능하다. 이를 통해 복셀화도 꾀할 수 있을 것이다.

다음은 지오메트리 쉐이더의 예시 코드다.

``` c++
"#version 430 core                             \n"
"layout (triangles) in;                        \n"
"layout (points, max_vertices = 3) out;        \n"
"void main(void)                               \n"
"{                                             \n"
"    int i;                                    \n"
"                                              \n"
"    for (i = 0; i < gl_in.length(); i++)      \n"
"    {                                         \n"
"        gl_Position = gl_in[i].gl_Position;   \n"
"        EmitVertex();                         \n"
"    }                                         \n"
"}                                             \n"
```

이 지오메트리 쉐이더는 버텍스를 확인할 수 있도록 삼각형 프리미티브를 점으로 변환한다.

1. `layout (triangle) in` 에서, 지오메트리 쉐이더가 입력 프리미티브로 삼각형을 입력받는다는 것을 알 수 있다. `layout (point, max_vertices = 3) out` 으로는 지오메트리 쉐이더가 **한 번 처리를 할 때**, 점으로 최종 프리미티브를 생성할 때 생성할 수 있는 **최대 정점의 개수**가 $ 3 $ 개라는 것을 *OpenGL* 에 알린다.
2. 함수 바디에서는 `gl_in` 배열의 모든 정점에 대해 루프를 돌면서 `EmitVertex()` 한다. 배열의 크기는 **`.length()`** 으로 알 수 있다.
3. 염두해야 할 점은, ***Geometry shader*** 는 쉐이더 프로그램 종료 시에, **자동으로 EndPrimitive() 을 호출한다**. 따라서 예제에서는 명시적으로 코드를 쓸 필요가 없었던 것이다. 

## 3.5 Primitive assembly, Clipping, Rasterization

프론트엔드의 처리가 다 끝난 후에는, 백엔드의 고정 함수 파트가 일련의 작업을 수행한다. 이 때 3차원의 공간을 클립 공간의 버텍스 형태로 받아서, **2D 화면의 픽셀로 변환하고**, **픽셀 차례로 색상을 결정**해서 화면에 출력하게 된다.

* *back-end* 의 첫 번째 단계는 ***Primitive Assembly*** 라고 하며, **정점들을 선과 삼각형, 혹은 점으로 그룹화**한다. 각 버텍스들의 집합이 진짜 최종적으로 그룹화가 되서 프리미티브가 구성이 되면 보이는 영역에 대해 ***Clipping*** 된다. 이 때 클리핑이 되는 기준은 ***Viewport*** 에서 벗어나는지이다.
* 마지막으로 클리핑되어 남아있는 프리미티브들은 ***Rasterizer*** 라는 스테이지에 보내는데, 여기서 어떤 픽셀들이 프리미티브에 가려지는 가를 가려내서 해당 픽셀들의 목록을 ***Fragment shading*** (픽셀 쉐이딩) 스테이지에 넘겨서 픽셀의 색을 결정한다.

### 3.5.1 Clipping

이 때까지, 좌표 값을 설정할 때 `vec3` 이 아닌 **`vec4`** 임을 알 수 있었는데, 그 이유는 계산을 조금 더 편하게 하기 위해서이다. 

* 이렇게 축이 4개로 설정된 좌표를 ***동차 좌표 (homogeneous coordinate)*** 라고 한다. 이 좌표계를 쓰면, 카테시안 좌표계 ($ (x, y, z) $) 의 좌표를 가지고 계산하는 것보다 상당수의 계산이 편해진다. 프론트엔드에서는 동차 좌표를 쓴다.
* 다만, *Clipping* 은 카테시안 좌표계에서 하지 않으면 안되기 때문에 이 동차 좌표계를 카테시안 좌표계로 바꾸는 ***원근 나눗셈***을 수행해서 좌표계를 보정한다.
  * 원근 나눗셈은, 동차 좌표계의 마지막 축인 $ w $ 의 값으로 $ x, y, z$ 축을 나누는 것을 말한다. 이 경우 $ w $ 의 값에 따라서 축소 혹은 확대의 효과를 기대할 수 있다.
* 원근 나눗셈 이후에는 *정규화된 디바이스 공간*에 있게 된다. 클립 공간과는 다른 점은 $ (x, y) $ 축에 대해서는 $ [-1, 1] $ 의 값을 가질 수 있지만, **$ (z) $** 축에 대해서는 $ [0, 1] $ 까지의 영역만을 가진다. 이 영역에 포함된 지오메트리 프리미티브만이 **사용자에게 보이게 된다.**
* 그 후에, *OpenGL* 은 각 프리미티브의 정점이 어떤 면에 놓여있는 가를 확인해서 (정점이 그려지는 순서 등을 고려한다) **Clipping** 을 수행한다. 프리미티브의 각 평면은 *"바깥"* 혹은 *"안*"쪽을 가지는데 *OpenGL* 에서 바깥쪽을 버릴지 안쪽을 버릴지 선택할 수 있다.

### 3.5.2 Viewport 변환

* Clipping 이후의 모든 프리미티브의 정점들은 $ ([-1, 1], [-1, 1], [0, 1]) $ 의 값을 가지고 있는데 이것을 $ W\text{width} , H\text{height} $ 의 스크린 공간에 맞춰 넣어야 한다. 따라서 다음과 같은 식으로 ***Viewport transition*** 을 할 수 있다.

$$
\begin{pmatrix}x_w\\y_w\\z_w\end{pmatrix} =
\begin{pmatrix}\begin{align}
\tfrac{p_x}{2}x_{d} & + o_x\\
\tfrac{p_y}{2}y_{d} & + o_y\\
\tfrac{f - n}{2}z_{d} & + \tfrac{n + f}{2}\end{align}\end{pmatrix}
$$

* 적용될 스케일과 오프셋은 **Viewport 경계를 통해 결정된다.** 따라서 *OpenGL* 에서는 이를 조절하는 함수를 제공하고 있다.
  * ***`glViewport()`*** , ***`glDepthRange()`***

### 3.5.3 Culling

옵션에 의해서 Viewport 변환 이후 거치는 스테이지이며, 삼각형이 관찰자의 방향을 바라보고 있는가, 반대 방향을 바라보면서 프리미티브를 생성하는 가를 결정해서 **해당 삼각형을 그릴지 말지를 결정한다.** 위에서 본 `FRONT`, `BACK` 이 바로 이것이다.

* 대개 삼각형이 뷰어가 보는 방향과 같다면 이는 **FRONT** 이고, 그렇지 않다면 **BACK** 이다. 보통 후면 방향이면 메쉬가 닫혀 있을 때 다른 정면 삼각형에 의해서 가려지게 되거나 아예 렌더링을 하지 않는다.
* 삼각형이 정면인가, 후면인가를 확인하기 위해서 *OpenGL* 은 스크린 공간 (윈도우 공간) 에서의 ***양의 면적***을 계산한다. 즉, 해당 삼각형의 **외적을 계산**해서 양인가 음인가를 통해 정면 / 후면 방향을 결정한다.
  * 정 계산하기 어려우면, 왼손을 이용해 외적 값의 방향을 가늠재는 것도 좋은 방법이다.

$$
a = \frac{1}{2}\sum_{i=1}^{n-1}w^i\times w^{i+1}
$$

따라서 합이 양의 방향이면 정면이고, 음의 방향이면 후면이다. 그런데 자세히 보면 프리미티브의 정점의 생성 순서가 ***반시계 방향 (CCW)*** 이면 이는 양의 방향이고 (정면) ***시계 방향 (CW)*** 이면 음의 방향 (후면) 임을 알 수 있다.

* ***`glFrontFace()`*** 으로 어느 면이 정면인지를 설정할 수 있다.

기본적으로 *OpenGL* 은 방향에 상관없이 모든 삼각형을 렌더링한다.
**컬링을 활성화**하기 위해서는 `glEnable(GL_CULL_FACE)` 을 호출해서 사용한다. 기본적으로는 `GL_CCW` 로 설정되어 있기 때문에 반시계 방향의 프리미티브만 추후 래스터화를 거치게 된다.

* ***`glCullFace(GLenum)`*** 을 사용해서 `glFrontFace()` 을 거쳐서 나온 정면 혹은 후면 중 어느 면을 *그리지 않을 것인가*를 설정할 수 있다. 다만, 점과 선은 삼각형과는 달리 면적을 가질 수 없기 때문에 컬링이 적용되지 않는다.

### 3.5.4 Rasterization

* ***Rasterization*** 은 화면 상의 프래그먼트들이 선이나 삼각형의 프리미티브에 의해서 범위 안에 있어 영향을 받는지 받지 않는지를 결정한다.
  * *OpenGL* 시스템은 삼각형에 대한 반공간 (half-space) 방식을 사용하여, 해당 프리미티브가 삼각형의 안에 있는가 아닌가를 판별한다. 이 방법은 상대적으로 단순하기 때문에 병렬화가 가능하다.

## 3.6 Fragment Shader (Pixel shader)

* ***Fragment shader*** 는 *OpenGL* 의 그래픽스 파이프라인에서 마지막으로 프로그래밍이 가능한 스테이지다. *Rasterization* 이후의 결정된 각 프래그먼트의 색상을 결정해서, *Framebuffer* 에 보내어 최종으로 스크린에 해당 색 혹은 영향을 받은 최종 색이 그려질 수 있도록 한다.
  * *Rasterizer* 와 *Fragment shader* 부분이 가장 연산량이 폭발하는데, 왜냐면 각 삼각형이 래스터화를 거치면서 무수한 프래그먼트를 생산해내기 때문이다.

다음은 픽셀 쉐이더로 간단한 색상을 입히는 코드이다.

``` c++
const GLchar* fs[] = {
    "#version 430 core\n"
    "out vec4 color;\n"
    "void main(void) {\n"
    "color = vec4(sin(gl_FragCoord.x * 0.25) * 0.5 + 0.5, \n"
    "             cos(gl_FragCoord.y * 0.25) * 0.5 + 0.5, \n"
    "             sin(gl_FragCoord.x * 0.15) * cos(gl_FragCoord.y * 0.15), 1.f); }"
}
```

* ***`gl_FragCoord`*** 는 **윈도우 안에서의 프래그먼트의 위치**를 나타낸다.
* 픽셀 쉐이더 역시 다른 스테이지와 마찬가지로 `in` 등의 specifier 로 입력을 직접 내리거나 이전 스테이지에서 가져올 수도 있다. 예를 들면, VS 와 FS 만 있는 스테이지의 경우에는 간단하게 인터페이스 블록 등을 전달하는 것이 된다.
* **Fragment shader** 의 입력은 다른 스테이지와는 다르게 약간 차이점이 존재한다.
  * 쉐이더 스테이지의 입력값이 래스터화 되서 만들어지는 세부 프리미티브 등에 따라서 **선형 보간**이 된다. 

## 3.7 Frame buffer 동작

* ***Framebuffer*** 는 *OpenGL* 의 파이프라인 동작 중에서 마지막에 해당된다. 화면에 보이는 영역을 나타내고, 영역의 픽셀의 컬러 외에도 *z-depth value* 나 스텐실 값 등을 저장하고 있다.
  * 거의 어플리케이션의 윈도우를 말하고, 프레임 버퍼 자체는 **OS가 소유**한다. 윈도우 시스템은 기본적으로 하나 이상의 프레임 버퍼를 제공하는데, *off-screen* 영역의 렌더링을 원한다면 별도로 프레임 버퍼를 제공하게 할 수 있다.
  * **Framebuffer object** 는 Pixel shader 가 픽셀을 쓸 위치 및 포맷 등을 저장한다. 하지만 프레임버퍼 객체에 저장되지 않는 ***Pixel operation*** 상태도 존재한다.

### 3.7.1 Pixel operation

프래그먼트 쉐이더가 색을 결정지은 후에, 이 색 버퍼가 윈도우에 바로 쓰이지는 않는다. 윈도우에 출력하기 까지 많은 일들이 부수로 일어난다. 이 부수적인 일들은 옵션으로 켜거나 끌 수 있다.

1. ***Scissor test (가위 테스트)***
   사용자가 정의한 사각형 범위에 대해서 프래그먼트를 테스트해서, 범위 밖이면 출력을 하지 않고 안이면 출력을 하도록 진행한다.
2. ***Stencil test (스텐실 테스트)***
   어플리케이션에서 설정한 **참조값**과 **스텐실 버퍼의 내용을 비교**한다. 멀티 샘플링과 같은 테크닉을 사용하지 않는 한, 스텐실 버퍼는 **픽셀 당 하나의 값**을 사용한다.
3. ***Depth test (깊이 테스트)***
   프래그먼트의 $ z $ 좌표와 **깊이 버퍼**의 내용을 비교해서 특정 오퍼레이션을 수행한다. 깊이 버퍼 역시 스텐실 버퍼와 같이 메모리 공간을 가진다.
   * 깊이 버퍼의 값은 $ [0, 1] $ 사이의 값을 가지며, $ 0 $ 이 가장 가깝고 $ 1 $ 이 가장 멀다. 기본으로 *OpenGL* 은 깊이 테스트를 할 때, 해당 픽셀의 $ z $ 값을 버퍼의 값과 비교해서 $ z $ 가 작으면 해당 픽셀이 스크린에 보이게끔 한다.
4. 그 후에 프레임버퍼의 값 저장 형식에 따라, **부동소수점** 이거나 **정규화된 정수**라면 ***Blending (블렌딩)***을 수행할 것이고 그렇지 않다면 논리곱과 같은 것을 적용해서 프레임 버퍼에 다시 저장할 수 있다.

## 3.8 Compute shader

* ***Compute shader*** 는 그래픽스와는 별개로 동작하는 파이프라인 스테이지이다. 이 쉐이더는 그래픽스 프로세서의 계산 파워를 사용하는 방법 중 하나다. 